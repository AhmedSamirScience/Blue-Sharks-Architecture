################################################################################################
# ğŸ‘‡ DataBinding Rule: Keep DataBinding-generated classes for the offlinedata feature module
################################################################################################

# Why?
# - The Data Binding compiler generates binding classes like ActivityBasicRdactivityBinding
#   inside the `databinding` package.
# - When R8 obfuscation is enabled, these classes may be renamed to short names like `a.a`.
# - If multiple modules contain DataBinding classes and are obfuscated separately, this causes:
#     âŒ `Type a.a is defined multiple times` error at merge/dex time.

# What this rule does:
# - Keeps all classes under `com.samir.bluearchitecture.offlinedata.databinding`
# - Prevents renaming, shrinking, and removal of their fields and methods
# - Ensures these classes remain accessible and uniquely named across modules

# When is it needed?
# âœ… Required in multi-module projects when:
#   - DataBinding is enabled in multiple feature modules
#   - R8/ProGuard is enabled for each module
# âŒ Not needed if you disable minification in all but the final app module

# Helps prevent:
# - Duplicate class errors during build
# - ClassNotFoundException or NoSuchMethodException at runtime
# - Debugging nightmares due to stripped/mangled binding classes

# Safe and minimal â€” scoped to DataBinding only for offlinedata module.
-keep class **.databinding.** { *; }
################################################################################################



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ› ï¸ Hilt/Dagger Generated Classes â€“ Required for Dependency Injection to work
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# ğŸ“Œ WHY THIS IS NEEDED:
# These rules preserve the names and structure of classes auto-generated by Hilt and Dagger
# such as _GeneratedInjector, _Factory, and _HiltModules classes.
# These classes are required at runtime to correctly wire up dependency injection graphs.

# âš™ï¸ WHAT EACH RULE DOES:

# âœ… Keeps injector classes generated by Hilt, e.g., MyApp_GeneratedInjector
# These are used to inject dependencies into Android components (Application, Activities, etc.)
-keep class **.*_GeneratedInjector { *; }

# âœ… Keeps factory classes generated by Dagger/Hilt for assisted injection and ViewModel creation
# These include ViewModel_AssistedFactory, or Foo_Factory for @Inject constructors
-keep class **.*_Factory { *; }

# âœ… Keeps internal module-related classes generated by Hilt like:
#    - ActivityModule_ProvideSomethingFactory
#    - HiltModules_ContributesAndroidInjector*
-keep class **.*_HiltModules* { *; }

# ğŸ“¦ These rules apply across all packages (multi-module friendly via `**`)
# âš ï¸ Required especially in RELEASE builds with R8 minification enabled

# ğŸ” Without these, you may face:
# - java.lang.NoSuchMethodException at runtime
# - Hilt crashing during injection setup
# - Missing ViewModel factories or component bindings
################################################################################################


################################################################################################
# ğŸ“¦ Module: offliedata.main.di
# ğŸ” WHY:
# - This rule preserves all Dagger/Hilt-related DI classes you defined manually under `.di`
# - DI classes (e.g., @Module, @Provides, @Binds) must be preserved for runtime injection

# âœ… WHAT IT DOES:
# - Prevents removal or renaming of any class under `com.samir.bluearchitecture.offlinedata.main.di`
# - Keeps their constructors, methods, and fields fully accessible to the Hilt runtime

# âš ï¸ REQUIRED:
# - For Hilt/Dagger setup to function correctly across feature modules
# - Especially when using R8 shrinking in each feature module (like offlinedata)

-keep class com.samir.bluearchitecture.offlinedata.di.** { *; }
################################################################################################



################################################################################################
# ğŸ§© Keep Class Names in offlinedata.main (but allow shrink/obfuscation of internals)
#
# ğŸ” WHY:
# - Some classes (e.g., Fragments or ViewModels) in this package may be accessed by name:
#     - From navigation XML or FragmentContainerView
#     - By reflection (e.g., Hilt ViewModelFactory or SavedStateHandle)
#
# âœ… WHAT IT DOES:
# - Preserves class names only â€” allows the classes to be removed if unused
# - Allows member renaming (fields and methods still optimized)

# ğŸ§  USE WHEN:
# - You want R8 to shrink aggressively, but still require class names for reflection

# âš ï¸ NOTE:
# - If you're seeing ClassNotFoundException errors, combine this with selective `-keep` rules

-keepnames class com.samir.bluearchitecture.offlinedata.**
################################################################################################



################################################################################################
# ğŸ§© Keep Login Domain Model Fully Intact (fields + methods)
#
# ğŸ” WHY:
# - The `Login` class is a Kotlin `data class` used across:
#     - ViewModels
#     - UseCases
#     - Workers (e.g., LoginWorker)
#     - Repositories
# - Its properties (e.g., `chemistID`, `errorMessage`) are often accessed:
#     - Directly (`login.chemistID`)
#     - Indirectly via reflection (e.g., logging, serialization, mapping)
#
# ğŸš« ISSUE:
# - In release builds, R8 may:
#     - Strip unused methods like `componentN()`, `copy()`, `toString()`
#     - Rename or remove fields accessed reflectively
#     - Obfuscate property names â€” leading to `NoSuchMethodError` or broken serialization
#
# âœ… WHAT IT DOES:
# - Keeps the entire class `Login` intact:
#     - Class name
#     - Fields
#     - Kotlin-generated methods (copy, toString, hashCode, etc.)
#     - Java-style accessors (if used via Java or Gson)
#
# ğŸ§  USE WHEN:
# - A domain model is passed to/from a Worker or ViewModel
# - It's mapped, serialized, or logged
# - You're seeing `NoSuchMethodError`, `IllegalAccessException`, or broken Gson parsing

-keep class com.samir.bluearchitecture.offlinedata.data.dataSource.** { *; }
-keep class com.samir.bluearchitecture.offlinedata.domain.useCase.** { *; }
################################################################################################
